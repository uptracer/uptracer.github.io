{"meta":{"title":"Fighting_Peter","subtitle":null,"description":"月亮是否只在你看着他的时候才存在","author":"uptracer","url":""},"pages":[{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-03T03:18:37.293Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-03T08:42:39.437Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2020-05-03T05:47:59.000Z","updated":"2020-05-03T06:26:51.003Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-05-03T05:20:57.009Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-05-03T08:40:03.061Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Fighting_Peter] 与&nbsp; uptracer&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-05-03T06:29:06.603Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-05-03T06:16:14.211Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"tags","date":"2020-05-03T06:14:16.000Z","updated":"2020-05-03T06:36:53.066Z","comments":true,"path":"tags/图集/index.html","permalink":"/tags/图集/index.html","excerpt":"","text":"","keywords":"pictures"}],"posts":[{"title":"并查集简单拓展","slug":"并查集简单拓展","date":"2020-05-16T05:47:18.000Z","updated":"2020-05-16T05:50:46.234Z","comments":true,"path":"2020/05/16/并查集简单拓展/","link":"","permalink":"/2020/05/16/并查集简单拓展/","excerpt":"","text":"并查集简单拓展1.并查集基本操作int find(int x)//路径压缩办找爸爸 { if(x!=p[x]) p[x]=find(p[x]); return p[x]; } void merge(int x,int y)//合并 { int px=find(x),py=find(y); if(px!=py) p[px]=py; } 2.并查集求反集——洛谷P1892 [BOI2003]团伙对于并查集通常维护的是两个东西有相关性，对于对立性需要新的方式来维护 第二天的时候，我了解到还有拓展域并查集，然后了解了相关操作后发现原来这个并查集求反集就是最简单的拓展域hh，较为复杂的拓展域可以做做食物链这个题。 题目描述 1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是：我朋友的朋友是我的朋友；我敌人的敌人也是我的朋友。两个强盗是同一团伙的条件是当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你最多有多少个强盗团伙。 输入格式 输入的第一行是一个整数N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。 第二行M(1&lt;=M&lt;=5000)，表示关于强盗的信息条数。 以下M行，每行可能是F p q或是E p q（1&lt;=p q&lt;=N），F表示p和q是朋友，E表示p和q是敌人。输入数据保证不会产生信息的矛盾。 输入格式 输出只有一行，表示最大可能的团伙数。 题目分析 对于朋友这个关系很容易用并查集来维护。如果是敌人呢？这个对立条件我们可以建立自己的一个虚拟的敌人与对方形成朋友从而间接的把敌人的敌人和自己连接到一个并查集里。因此我们可以将p[2*n]开成两倍长p[i]的虚拟敌人为p[n+i]凡是跟虚拟敌人相连的人都会被连到一起。 注意：将虚拟节点的父亲连到实际的节点（因为虚拟节点是不存在的） 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=2010,M=10010; int n,m; int p[N]; int find(int x) { if(x!=p[x]) p[x]=find(p[x]); return p[x]; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=2*n;i++) p[i]=i; while(m--) { char t; int a,b; cin&gt;&gt;t&gt;&gt;a&gt;&gt;b; if(t==&#39;E&#39;) { p[find(a+n)]=p[find(b)];//将虚拟节点的父亲连向实际节点 p[find(b+n)]=p[find(a)];//p[find(a)]=p[find(b+n)]这样不对!!! } else { int pa=find(a),pb=find(b); p[pa]=pb; } } int res=0; for(int i=1;i&lt;=n;i++) if(i==p[i]) res++; cout&lt;&lt;res&lt;&lt;endl; return 0; } 3.并查集删除操作——HDU 2473 Junk-Mail Filter所谓并查集就是合并和查询但是偶尔也会遇见删除的操作 题目描述 Recognizing junk mails is a tough task. The method used here consists of two steps:1) Extract the common characteristics from the incoming email.2) Use a filter matching the set of common characteristics extracted to determine whether the email is a spam. We want to extract the set of common characteristics from the N sample junk emails available at the moment, and thus having a handy data-analyzing tool would be helpful. The tool should support the following kinds of operations: a) “M X Y”, meaning that we think that the characteristics of spam X and Y are the same. Note that the relationship defined here is transitive, sorelationships (other than the one between X and Y) need to be created if they are not present at the moment. b) “S X”, meaning that we think spam X had been misidentified. Your tool should remove all relationships that spam X has when this command is received; after that, spam X will become an isolated node in the relationship graph. Initially no relationships exist between any pair of the junk emails, so the number of distinct characteristics at that time is N.Please help us keep track of any necessary information to solve our problem. 输入格式 There are multiple test cases in the input file.Each test case starts with two integers, N and M (1 ≤ N ≤ 105 , 1 ≤ M ≤ 106), the number of email samples and the number of operations. M lines follow, each line is one of the two formats described above.Two successive test cases are separated by a blank line. A case with N = 0 and M = 0 indicates the end of the input file, and should not be processed by your program. 输出格式 For each test case, please print a single integer, the number of distinct common characteristics, to the console. Follow the format as indicated in the sample below. 题目大意 维护一个集合，支持合并和删除两种操作，最终输入有几类。 题目分析 维护能够支持删除操作的并查集。常规并查集的初始化的方法是把每个节点的父节点初始化成自己，p[u]=u，u这个节点就是整个集合的祖宗，此时，u点就有了两重身份：既是一个节点的名字，也是这个集合祖宗的名字，而删除操作的关键就是只改变这一个点的祖宗，而不能改变这个点所在集合的祖宗。因此要把每个节点名字的两重身份分离开，u只表示这个节点的名字，然后给他找一个祖宗（建立虚点），而且，u永远不会是u的祖宗。先给每一个节点建立一个父节点。于是我们让p[i]=i+n，1~n中第i个节点的父亲是n+i，大于n节点父亲还是自己，这样我们就可以把节点的名字和集合祖宗的名字分开。 void init()//我们可以这样初始化 { idx=n; for(int i=1;i&lt;=n;i++) p[i]=idx++;//遍历完后 idx应该等于2n+1 for(int i=n;i&lt;idx;i++) p[i]=i; } 对于删除操作，我们只需要将这个点的父亲指向一个新的节点（这个节点从未使用过），这样就可以完成删除。 void delete(int x) { p[x]=idx; p[idx]=idx;//除了1~n个节点，我们都将该节点的父亲指向自己 idx++;//这个相当于数组计数器，每次删除需要多开辟一个位置即未使用的节点 } 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; const int N=1200010; int p[N],idx; int n,m; bool st[N]; int find(int x) { if(x!=p[x]) p[x]=find(p[x]); return p[x]; } void init() { idx=n; for(int i=0;i&lt;n;i++) p[i]=idx++; for(int i=n;i&lt;idx;i++) p[i]=i; } int main() { int cnt=0; while(cin&gt;&gt;n&gt;&gt;m,m+n) { cnt++; init(); char op[2]; while(m--) { cin&gt;&gt;op; if(op[0]==&#39;M&#39;) { int x,y; cin&gt;&gt;x&gt;&gt;y; int px=find(x),py=find(y); p[px]=py; } else { int x; cin&gt;&gt;x; p[x]=idx; p[idx]=idx; idx++; } } memset(st,0,sizeof st); int res=0; for(int i=0;i&lt;n;i++) { int px=find(i); if(!st[px]) { st[px]=1; res++; } } printf(&quot;Case #%d: %d\\n&quot;,cnt,res); } return 0; } 4.单向并查集——洛谷P2835 刻录光盘对于并查集维护的关系都是双向的，但有些题目是单向的。 题目描述 在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！ 组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！ 可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！ 现在假设总共有N个营员（2&lt;=N&lt;=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。 现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？ 输入格式 先是一个数N，接下来的N行，分别表示各个营员愿意把自己获得的资料拷贝给其他哪些营员。即输入数据的第i+1行表示第i个营员愿意把资料拷贝给那些营员的编号，以一个0结束。如果一个营员不愿意拷贝资料给任何人，则相应的行只有1个0，一行中的若干数之间用一个空格隔开。 输出格式 一个正整数，表示最少要刻录的光盘数。 题目分析 对于单项并查集，我们只需要记录下这个节点有没有直系父亲即可 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int N=210; int p[N]; bool d[N]; int n; int find(int x) { if(x!=p[x]) p[x]=find(p[x]); return p[x]; } int main() { int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=1;i&lt;=n;i++) { int m,pi=find(i); while(cin&gt;&gt;m,m) { p[find(m)]=pi; d[m]=1;//有直系父亲 } } int res=0; for(int i=1;i&lt;=n;i++)//祖宗节点或者没有直系父亲的点 if(p[i]==i||d[i]==0) res++; cout&lt;&lt;res&lt;&lt;endl; return 0; } 5.带权并查集——d[i]到祖宗节点的距离int find(int x) { if(x!=p[x]) { int root=find(p[x]); d[x]+=d[p[x]]; p[x]=root; } return p[x]; } 总结并查集删除、单向并查集，并查集维护多种关系（①祖宗节点的距离来确定关系②拓展域维护多种关系）。记录下来方便复习。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"HDU二维斜率优化","slug":"HDU二维斜率优化","date":"2020-05-12T12:36:39.000Z","updated":"2020-05-12T12:38:01.410Z","comments":false,"path":"2020/05/12/HDU二维斜率优化/","link":"","permalink":"/2020/05/12/HDU二维斜率优化/","excerpt":"","text":"二维斜率优化一、HDU 3480 Division​题目描述 Little D is really interested in the theorem of sets recently. There’s a problem that confused him a long time.Let T be a set of integers. Let the MIN be the minimum integer in T and MAX be the maximum, then the cost of set T if defined as (MAX – MIN)^2. Now given an integer set S, we want to find out M subsets S1, S2, …, SM of S, such that and the total cost of each subset is minimal. 输入格式 The input contains multiple test cases.In the first line of the input there’s an integer $T$ which is the number of test cases. Then the description of $T$ test cases will be given.For any test case, the first line contains two integers $N (≤ 10000)$ and $M (≤ 5,000)$. $N$ is the number of elements in S (may be duplicated). $M$ is the number of subsets that we want to get. In the next line, there will be $N$ integers giving set S. 输出格式 For each test case, output one line containing exactly one integer, the minimal total cost. Take a look at the sample output for format. 题目大意 有一个集合，把这个集合分解成一定数量的自己，每一个子集有一个代价，代价计算方式是这个集合极差的平方。求这个集合分成相应数量集合的最小代价。 题目分析 很明显这个一个$dp$的题。 状态表示：①集合:$f[j][i]$表示将前$i$个数分成$j$个集合。②属性:划分的最小代价 状态计算：$f[j][i]=f[j-1][k]+(w[i]-w[k+1])^2$ $(j-1≤k&lt;i)$ 时间复杂度$O(mn^2)$对于题中的数据是吃不消的所以要优化。 斜率表示：$f[j-1][k]+w[k+1]^2=2w[i]w[k+1]+f[j][i]-w[i]^2$ 于是若写成$Y=kX+b$，那么$Y=f[j-1][k]+w[k+1],X=w[k+1]$ 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N=10010,M=5010; int n,m; int w[N],q[N]; int f[M][N]; int gety(int j,int a,int b) { return f[j][b]+w[b+1]*w[b+1]-f[j][a]-w[a+1]*w[a+1]; } int getx(int a,int b) { return w[b+1]-w[a+1]; } int main() { int T; cin&gt;&gt;T; for(int K=1;K&lt;=T;K++) { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; sort(w+1,w+1+n);//先排序 int tt,hh;//定义对头队尾 //初始话边界对于i个元素分成1组 for(int i=1;i&lt;=n;i++) f[1][i]=(w[i]-w[1])*(w[i]-w[1]); for(int j=2;j&lt;=m;j++)//从第二组开始讨论 { tt=1,hh=0;//初始化 q[tt]=j-1; for(int i=j;i&lt;=n;i++)//集合中的元素个数必须不小于分的组数 { int k=2*w[i]; while(tt&gt;hh&amp;&amp;gety(j-1,q[hh],q[hh+1])&lt;=k*getx(q[hh],q[hh+1])) hh++; f[j][i]=f[j-1][q[hh]]+(w[i]-w[q[hh]+1])*(w[i]-w[q[hh]+1]); while(tt&gt;hh&amp;&amp;gety(j-1,q[tt-1],q[tt])*getx(q[tt],i)&gt;=gety(j-1,q[tt],i)*getx(q[tt-1],q[tt])) tt--; q[++tt]=i; } } printf(&quot;Case %d: %d\\n&quot;,K,f[m][n]); } return 0; } 二、HDU 2829 Lawrence题目描述 T. E. Lawrence was a controversial figure during World War I. He was a British officer who served in the Arabian theater and led a group of Arab nationals in guerilla strikes against the Ottoman Empire. His primary targets were the railroads. A highly fictionalized version of his exploits was presented in the blockbuster movie, “Lawrence of Arabia”. You are to write a program to help Lawrence figure out how to best use his limited resources. You have some information from British Intelligence. First, the rail line is completely linear—-there are no branches, no spurs. Next, British Intelligence has assigned a Strategic Importance to each depot—-an integer from 1 to 100. A depot is of no use on its own, it only has value if it is connected to other depots. The Strategic Value of the entire railroad is calculated by adding up the products of the Strategic Values for every pair of depots that are connected, directly or indirectly, by the rail line. Consider this railroad: Its Strategic Value is 4×5 + 4×1 + 4×2 + 5×1 + 5×2 + 1×2 = 49. Now, suppose that Lawrence only has enough resources for one attack. He cannot attack the depots themselves—-they are too well defended. He must attack the rail line between depots, in the middle of the desert. Consider what would happen if Lawrence attacked this rail line right in the middle: The Strategic Value of the remaining railroad is 4×5 + 1×2 = 22. But, suppose Lawrence attacks between the 4 and 5 depots: The Strategic Value of the remaining railroad is 5×1 + 5×2 + 1×2 = 17. This is Lawrence’s best option. Given a description of a railroad and the number of attacks that Lawrence can perform, figure out the smallest Strategic Value that he can achieve for that railroad. 输入格式 There will be several data sets. Each data set will begin with a line with two integers, n and m. n is the number of depots on the railroad (1≤n≤1000), and m is the number of attacks Lawrence has resources for (0≤m&lt;n). On the next line will be n integers, each from 1 to 100, indicating the Strategic Value of each depot in order. End of input will be marked by a line with n=0 and m=0, which should not be processed. 输出格式 For each data set, output a single integer, indicating the smallest Strategic Value for the railroad that Lawrence can achieve with his attacks. Output each integer in its own line. 题目大意 有n个仓库每个仓库有一个权值，你可以轰炸m次n个仓库之间的铁路使他们断开，连续的仓库有一个总权值大小为每每两个仓库的权值的乘积之和，要求轰炸m次即让他们分成m+1个子序列的总权值和最小 题目分析 这也是一个$dp$的题 状态表示：①集合:$f[j][i]$表示对于前$i$个仓库轰炸$j$次的集合。②属性:最小 状态计算：$f[j][i]=f[j-1][k]+\\sum_{a=k+1}^i w[a]×(\\sum_{b=a+1}^i w[b])$ 我们用$s[i]=w[1]+w[2]+\\dots+w[i]$，$ms[i]=w[1]×s[1]+w[2]×s[2]+\\dots+w[i]×s[i]$ 于是上述式子可化简为$f[j][i]=f[j-1][k]+s[i]×(s[i]-s[k])+ms[k]-ms[i]$ 斜率表示：$f[j-1][k]+ms[k]=s[i]s[k]+f[j][i]-s^2[i]+ms[i]$ 于是若写成$Y=kX+b$，$Y=f[j-1][k]+ms[k]$，$X=s[k]$ 代码 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; typedef long long ll; const int N=1010; int n,m,q[N]; ll w[N],s[N],ms[N]; ll f[N][N]; ll gety(int j,int a,int b) { return f[j][b]+ms[b]-f[j][a]-ms[a]; } ll getx(int a,int b) { return s[b]-s[a]; } int main() { while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n||m) { for(int i=1;i&lt;=n;++i) { scanf(&quot;%lld&quot;,&amp;w[i]); s[i]=s[i-1]+w[i];//前缀和 ms[i]=ms[i-1]+w[i]*s[i];//w[i]s[i]的前缀和 f[0][i]=s[i]*s[i]-ms[i];//初始化边界 } int tt,hh; for(int j=1;j&lt;=m;++j) { tt=1,hh=0; //f[j-1][j]这个更新过后要吧第j的点加入队列，j前面的点没有意义要删去 q[tt]=j; for(int i=j+1;i&lt;=n;++i)//仓库的个数是i之间的铁路个数是i-1,所以i-1&gt;=j { ll k=s[i]; while(tt&gt;hh&amp;&amp;gety(j-1,q[hh],q[hh+1])&lt;=getx(q[hh],q[hh+1])*k) hh++; f[j][i]=f[j-1][q[hh]]+s[i]*(s[i]-s[q[hh]])+ms[q[hh]]-ms[i]; while(tt&gt;hh&amp;&amp;gety(j-1,q[tt-1],q[tt])*getx(q[tt],i)&gt;=gety(j-1,q[tt],i)*getx(q[tt-1],q[tt])) tt--; q[++tt]=i; } } printf(&quot;%lld\\n&quot;,f[m][n]); } return 0; } 总结对于二维斜率优化，有一个关键的就是在第一层循环的时候初始化的tt=1,hh=0,q[tt]=j至于为什么需要q[tt]=j暂时还想的不是很明白:)，目前认为是上一层只有一个点有效的。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"奇怪的建图方式","slug":"奇怪的建图方式","date":"2020-05-11T09:50:39.000Z","updated":"2020-05-12T12:37:32.280Z","comments":false,"path":"2020/05/11/奇怪的建图方式/","link":"","permalink":"/2020/05/11/奇怪的建图方式/","excerpt":"","text":"奇怪的建图方式一、2020.4.23学校测试题题目描述 蒟蒻回家种地后，突然听说武汉迫切需要医疗物资。他老家的田地在s点，可是武汉在e点，为了运输货物，中途需要经过很多城市，这导致快递费非常的贵，于是他准备自己开车，可是现在油价也不便宜，他尽量省一些油。 已知蒟蒻掌握着熟练的漂移技巧，当他在城市A时，他可以使用漂移到达城市B，这样耗费的油量为：$t×(A xor B)$，其中$t$为常数，$xor$为按位异或运算。此外他还可以不漂移，直接走公路，消耗的油量会给出。现在蒟蒻要从s到e点，请问他最少消耗多少升油? 输入格式 第一行三个数n($3≤n≤50000$)，m($0≤m≤100000$)，t($1≤t≤10^9$)代表有n个城市，共有m条连接城市的公路，和常数t。 第二行有两个数s，e，代表起点为s号城市，终点为e号城市。 第3到第m+2行，每行有三个数x，y，z，代表一条公路连接x号和y号城市，通过这条公路需要消耗z升 油，道路均为双向，两个城市间可能有多条道路连通。城市标号从1开始 输出格式 一行，一个数，为消耗的最少油量。 分析 很明显，题目是一个最短路问题，考虑对漂移方式的建图：如果将该点到其余所有点的漂移的边建出来发现最多可能需要建立$\\cfrac{n(n-1)}{2}$条边，所以总的边数为$m+\\cfrac{n(n-1)}{2}$，对于$dijkstra$算法复杂度是吃不消的。所以需要对漂移操作找一个更优的建边方式： 建异或的边考虑结合律(对于每一位的位运算是独立的考虑每一位的位运算然后相加)不需要把所有的边建出来 1101 -&gt; 1001 -&gt; 1011 -&gt; 10101101 -&gt; 1001 的代价是 1001001 -&gt; 1011 的代价是 101011 -&gt; 1010 的代价是 1 1101 -&gt; 10101101 -&gt; 1010 的代价是 111 所以发现上述是等价的，每次只考虑改变一个二进制位 总结一下：对于一个点到另一个点是对改变k次二进制位，每次对当前的点改变一个二进制位，能够达到漂移到任意点的效果。（但是要借助0这个点以达到枚举所有漂移情况） 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt;PLI; const int N=50010,M=1000020; int h[N],e[M],ne[M],idx; ll w[M]; ll dist[N]; bool st[N]; int n,m,t,start,ed; void add(int a,int b,ll c) { e[idx]=b; w[idx]=c; ne[idx]=h[a]; h[a]=idx++; } ll dijkstra() { memset(dist,0x3f,sizeof dist); priority_queue&lt;PLI,vector&lt;PLI&gt;,greater&lt;PLI&gt; &gt;heap; heap.push({0,start}); dist[start]=0; while(heap.size()) { int t=heap.top().second; heap.pop(); if(st[t]) continue; st[t]=1; for(int i=h[t];i!=-1;i=ne[i]) { int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) { dist[j]=dist[t]+w[i]; heap.push({dist[j],j}); } } } return dist[ed]; } int main() { memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;start&gt;&gt;ed; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c),add(b,a,c); } for(int i=0;i&lt;=n;i++)//借助0这个点 for(int j=0;j&lt;17;j++) if((i^(1&lt;&lt;j))&lt;=n) add(i,i^(1&lt;&lt;j),1ll*t*(1&lt;&lt;j)); cout&lt;&lt;dijkstra()&lt;&lt;endl; return 0; } //由于现在没有测试平台，此代码不一定正确但是思想没问题 二、算法进阶指南——装满的油箱题目描述 有N个城市（编号0、1…N-1）和M条道路，构成一张无向图。 在每个城市里边都有一个加油站，不同的加油站的单位油价不一样。 现在你需要回答不超过100个问题，在每个问题中，请计算出一架油箱容量为C的车子，从起点城市S开到终点城市E至少要花多少油钱？ 注意： 假定车子初始时油箱是空的。 输入格式 第一行包含两个整数N和M。 第二行包含N个整数，代表N个城市的单位油价，第i个数即为第i个城市的油价pipi。 接下来M行，每行包括三个整数u,v,d，表示城市u与城市v之间存在道路，且车子从u到v需要消耗的油量为d。 接下来一行包含一个整数q，代表问题数量。 接下来q行，每行包含三个整数C、S、E，分别表示车子油箱容量、起点城市S、终点城市E。 输出格式 对于每个问题，输出一个整数，表示所需的最少油钱。 如果无法从起点城市开到终点城市，则输出”impossible”。 每个结果占一行。 数据范围 1≤N≤1000,1≤M≤10000,1≤p_i≤1001≤d≤100,1≤C≤100分析 如何表示状态？ 对于每个状态有两点决定：①现在在什么地方②现在油箱有多少油。因此考虑分层图即拆点建图dist[k][c]：表示目前在k这个位置邮箱剩余油量为c这个状态。 如何转移状态？①对于k来说遍历该点的临边②对于c来说可以在该点加油（加油可以加任意升但是只需要考虑每次加一升油就可以实现加任意升油情况） 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N=1010,M=20010,C=110; int h[N],e[M],ne[M],w[M],idx; int price[N]; int dist[N][C]; bool st[N][C]; int n,m; struct ver { int d,u,c; bool operator&lt; (const ver &amp;w) const { return d&gt;w.d; } }; void add(int a,int b,int c) { e[idx]=b; ne[idx]=h[a]; w[idx]=c; h[a]=idx++; } int dijkstra(int start,int ed,int cap) { memset(dist,0x3f,sizeof dist); memset(st,0,sizeof st); priority_queue&lt;ver&gt; heap; heap.push({0,start,0}); dist[start][0]=0; while(heap.size()) { auto t=heap.top(); heap.pop(); if(t.u==ed&amp;&amp;t.c==0) return t.d; if(st[t.u][t.c]) continue; st[t.u][t.c]=1; if(t.c&lt;cap) { if(dist[t.u][t.c+1]&gt;t.d+price[t.u]) { dist[t.u][t.c+1]=t.d+price[t.u]; heap.push({dist[t.u][t.c+1],t.u,t.c+1}); } } for(int i=h[t.u];i!=-1;i=ne[i]) { int j=e[i]; if(t.c&gt;=w[i]) { if(dist[j][t.c-w[i]]&gt;t.d) { dist[j][t.c-w[i]]=t.d; heap.push({dist[j][t.c-w[i]],j,t.c-w[i]}); } } } } return -1; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); for(int i=0;i&lt;n;i++) cin&gt;&gt;price[i]; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c),add(b,a,c); } int query; cin&gt;&gt;query; while(query--) { int a,b,c; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; int t=dijkstra(a,b,c); if(t==-1) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;t&lt;&lt;endl; } return 0; } 总结发现上述两题有一个共同特点：每次进行1次操作来实现k次操作都用。第一题：改变k次二进制位每次考虑改变一位。第二题：每次可以加k升油考虑每次只加一升油。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"图论","slug":"图论","permalink":"/tags/图论/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"树状数组","slug":"树状数组","date":"2020-05-06T07:00:26.000Z","updated":"2020-05-11T09:49:12.260Z","comments":false,"path":"2020/05/06/树状数组/","link":"","permalink":"/2020/05/06/树状数组/","excerpt":"","text":"树状数组聊聊前缀和比如数组 int a[7]={1,2,3,4,5,6,7} 如果需询问数组从第l个数到第r个数的和暴力做法时间复杂度为$O(n)$ 不过我们可以预处理一个前缀和数组 int b[7]={1,3,6,10,15,21,28} 比如要询问[l,r]区间的和我们可以这样做b[r]-b[l-1]这也时间复杂度为$O(1)$ 但是问题来了，如果我们要既要修改数组中元素的值，有要进行上述区间查询操作呢？ 我们发现每次我们修改原数组中元素的值时间复杂度为$O(1)$但是如果修改前缀和数组中元素的值时间复杂度将会退化到$O(n)$ 总结一下： 数组 修改元素的值时间复杂度 区间求和时间复杂度 原数组 O(1) O(n) 前缀和数组 O(n) O(1) 我们可以发现如果需要单点更新和区间查询两种操作时间复杂度都是$O(n)$ 什么是树状数组?树状数组是一种便于进行单点更新和区间查询的数据结构 树状数组相关操作 二进制中最后一个1——$lowbit$ int lowbit(int x) { return x&amp;-x; } 单点更新 我们对数组位置为x的元素加上c //树状数组为tree，数组元素个数为n，数组下标从0开始 void add(int x,int c) { for(;x&lt;=n;x+=lowbit(x)) tree[x]+=c; } 区间求和 //求出[1,x]数组中的总和即前缀和 int sum(int x) { int res=0; for(;x;x-=lowbit(x)) res+=tree[x]; return res; } 局限性我们很容易发现上述树状数组只适用于单点更新和区间查询，但是如果是区间修改和单点查询好像力不从心 差分在树状数组中的应用告诉你个好消息如果有差分的介入，那么树状数组可以进行区间更新和单点查询当然也可以进行更厉害的区间更新和区间查询。 区间更新、单点查询我们把$tree[]$数组构造成一个差分数组还是看题吧 题目 给定长度为N的数列A，然后输入M行操作指令。 第一类指令形如“C l r d”，表示把数列中第l~r个数都加d。 第二类指令形如“Q X”，表示询问数列中第x个数的值。 对于每个询问，输出一个整数表示答案。 输入格式 第一行包含两个整数N和M。 第二行包含N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式 对于每个询问，输出一个整数表示答案。 每个答案占一行。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N=100010; ll tree[N]; int n,m; int lowbit(int x) { return x&amp;-x; } void add(int x,int c) { for(;x&lt;=n;x+=lowbit(x)) tree[x]+=c; } ll sum(int x) { int res=0; for(;x;x-=lowbit(x)) res+=tree[x]; return res; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { int a; cin&gt;&gt;a; add(i,a); add(i+1,-a); } while(m--) { char t; cin&gt;&gt;t; if(t==&#39;Q&#39;) { int x; cin&gt;&gt;x; cout&lt;&lt;sum(x)&lt;&lt;endl; } else { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,c); add(b+1,-c); } } return 0; } 我们可以发现对于上述代码即在建树的过程中建成差分树的形式即可 区间更新、区间查询原数组a[]，对于区间更新我们可以维护一个差分数组b[] 如果我们维护数组a的前缀和我们可以发现有下面等式： \\sum_{i=1}^x a_i=\\sum_{i=1}^x\\sum_{j=1}^i b_i=\\sum_{i=1}^x(x-i+1)b_i变换一下： \\sum_{i=1}^x a_i=(x+1)\\sum_{i=1}^x b_i-\\sum_{i=1}^x b_i×i 于是我们可以维护两个差分树状数组$tree1[]$维护$ bi $、$tree2[]$维护$i*bi$ 给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一： 1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2、“Q l r”，表示询问 数列中第 l~r 个数的和。 对于每个询问，输出一个整数表示答案。 输入格式 第一行两个整数N,M。 第二行N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式 对于每个询问，输出一个整数表示答案。 每个答案占一行。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N=100010; int n,m; ll tree1[N],tree2[N]; //维护b[i] 维护i*b[i] int lowbit(int x) { return x&amp;-x; } void add(ll tree[],int x,ll c) { for(;x&lt;=n;x+=lowbit(x)) tree[x]+=c; } ll sum(ll tree[],int x) { ll res=0; for(;x;x-=lowbit(x)) res+=tree[x]; return res; } ll prefix_sum(int x) { return (x+1)*sum(tree1,x)-sum(tree2,x); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { int a; scanf(&quot;%d&quot;,&amp;a); add(tree1,i,a); add(tree1,i+1,-a); add(tree2,i,1ll*i*a); add(tree2,i+1,-1ll*(i+1)*a); } while(m--) { char t; int l,r; cin&gt;&gt;t&gt;&gt;l&gt;&gt;r; if(t==&#39;Q&#39;) { scanf(&quot;%d%d&quot;,&amp;l,&amp;r); cout&lt;&lt;prefix_sum(r)-prefix_sum(l-1)&lt;&lt;endl; } else { int d; scanf(&quot;%d&quot;,&amp;d); add(tree1,l,d),add(tree1,r+1,-d); add(tree2,l,l*d),add(tree2, r+1,-1ll*(r+1)*d); } } return 0; } 总结 2020/5/6学习树状数组，树状数组可以优化很多问题未来等遇到了在加进去 以上题目来自于$lyd$老师的《算法进阶指南》参考$lcf$大佬博客","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}