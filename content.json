{"meta":{"title":"Fighting_Peter","subtitle":null,"description":"月亮是否只在你看着他的时候才存在","author":"uptracer","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-05-03T08:40:03.061Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Fighting_Peter] 与&nbsp; uptracer&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-03T03:18:37.293Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-03T08:42:39.437Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-05-03T05:20:57.009Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"lab","date":"2020-05-03T05:47:59.000Z","updated":"2020-05-03T06:26:51.003Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-05-03T06:16:14.211Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-05-03T06:29:06.603Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"tags","date":"2020-05-03T06:14:16.000Z","updated":"2020-05-03T06:36:53.066Z","comments":true,"path":"tags/图集/index.html","permalink":"/tags/图集/index.html","excerpt":"","text":"","keywords":"pictures"}],"posts":[{"title":"HDU二维斜率优化","slug":"HDU二维斜率优化","date":"2020-05-12T12:36:39.000Z","updated":"2020-05-12T12:38:01.410Z","comments":false,"path":"2020/05/12/HDU二维斜率优化/","link":"","permalink":"/2020/05/12/HDU二维斜率优化/","excerpt":"","text":"二维斜率优化一、HDU 3480 Division​题目描述 Little D is really interested in the theorem of sets recently. There’s a problem that confused him a long time.Let T be a set of integers. Let the MIN be the minimum integer in T and MAX be the maximum, then the cost of set T if defined as (MAX – MIN)^2. Now given an integer set S, we want to find out M subsets S1, S2, …, SM of S, such that and the total cost of each subset is minimal. 输入格式 The input contains multiple test cases.In the first line of the input there’s an integer $T$ which is the number of test cases. Then the description of $T$ test cases will be given.For any test case, the first line contains two integers $N (≤ 10000)$ and $M (≤ 5,000)$. $N$ is the number of elements in S (may be duplicated). $M$ is the number of subsets that we want to get. In the next line, there will be $N$ integers giving set S. 输出格式 For each test case, output one line containing exactly one integer, the minimal total cost. Take a look at the sample output for format. 题目大意 有一个集合，把这个集合分解成一定数量的自己，每一个子集有一个代价，代价计算方式是这个集合极差的平方。求这个集合分成相应数量集合的最小代价。 题目分析 很明显这个一个$dp$的题。 状态表示：①集合:$f[j][i]$表示将前$i$个数分成$j$个集合。②属性:划分的最小代价 状态计算：$f[j][i]=f[j-1][k]+(w[i]-w[k+1])^2$ $(j-1≤k&lt;i)$ 时间复杂度$O(mn^2)$对于题中的数据是吃不消的所以要优化。 斜率表示：$f[j-1][k]+w[k+1]^2=2w[i]w[k+1]+f[j][i]-w[i]^2$ 于是若写成$Y=kX+b$，那么$Y=f[j-1][k]+w[k+1],X=w[k+1]$ 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N=10010,M=5010; int n,m; int w[N],q[N]; int f[M][N]; int gety(int j,int a,int b) { return f[j][b]+w[b+1]*w[b+1]-f[j][a]-w[a+1]*w[a+1]; } int getx(int a,int b) { return w[b+1]-w[a+1]; } int main() { int T; cin&gt;&gt;T; for(int K=1;K&lt;=T;K++) { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]; sort(w+1,w+1+n);//先排序 int tt,hh;//定义对头队尾 //初始话边界对于i个元素分成1组 for(int i=1;i&lt;=n;i++) f[1][i]=(w[i]-w[1])*(w[i]-w[1]); for(int j=2;j&lt;=m;j++)//从第二组开始讨论 { tt=1,hh=0;//初始化 q[tt]=j-1; for(int i=j;i&lt;=n;i++)//集合中的元素个数必须不小于分的组数 { int k=2*w[i]; while(tt&gt;hh&amp;&amp;gety(j-1,q[hh],q[hh+1])&lt;=k*getx(q[hh],q[hh+1])) hh++; f[j][i]=f[j-1][q[hh]]+(w[i]-w[q[hh]+1])*(w[i]-w[q[hh]+1]); while(tt&gt;hh&amp;&amp;gety(j-1,q[tt-1],q[tt])*getx(q[tt],i)&gt;=gety(j-1,q[tt],i)*getx(q[tt-1],q[tt])) tt--; q[++tt]=i; } } printf(&quot;Case %d: %d\\n&quot;,K,f[m][n]); } return 0; } 二、HDU 2829 Lawrence题目描述 T. E. Lawrence was a controversial figure during World War I. He was a British officer who served in the Arabian theater and led a group of Arab nationals in guerilla strikes against the Ottoman Empire. His primary targets were the railroads. A highly fictionalized version of his exploits was presented in the blockbuster movie, “Lawrence of Arabia”. You are to write a program to help Lawrence figure out how to best use his limited resources. You have some information from British Intelligence. First, the rail line is completely linear—-there are no branches, no spurs. Next, British Intelligence has assigned a Strategic Importance to each depot—-an integer from 1 to 100. A depot is of no use on its own, it only has value if it is connected to other depots. The Strategic Value of the entire railroad is calculated by adding up the products of the Strategic Values for every pair of depots that are connected, directly or indirectly, by the rail line. Consider this railroad: Its Strategic Value is 4×5 + 4×1 + 4×2 + 5×1 + 5×2 + 1×2 = 49. Now, suppose that Lawrence only has enough resources for one attack. He cannot attack the depots themselves—-they are too well defended. He must attack the rail line between depots, in the middle of the desert. Consider what would happen if Lawrence attacked this rail line right in the middle: The Strategic Value of the remaining railroad is 4×5 + 1×2 = 22. But, suppose Lawrence attacks between the 4 and 5 depots: The Strategic Value of the remaining railroad is 5×1 + 5×2 + 1×2 = 17. This is Lawrence’s best option. Given a description of a railroad and the number of attacks that Lawrence can perform, figure out the smallest Strategic Value that he can achieve for that railroad. 输入格式 There will be several data sets. Each data set will begin with a line with two integers, n and m. n is the number of depots on the railroad (1≤n≤1000), and m is the number of attacks Lawrence has resources for (0≤m&lt;n). On the next line will be n integers, each from 1 to 100, indicating the Strategic Value of each depot in order. End of input will be marked by a line with n=0 and m=0, which should not be processed. 输出格式 For each data set, output a single integer, indicating the smallest Strategic Value for the railroad that Lawrence can achieve with his attacks. Output each integer in its own line. 题目大意 有n个仓库每个仓库有一个权值，你可以轰炸m次n个仓库之间的铁路使他们断开，连续的仓库有一个总权值大小为每每两个仓库的权值的乘积之和，要求轰炸m次即让他们分成m+1个子序列的总权值和最小 题目分析 这也是一个$dp$的题 状态表示：①集合:$f[j][i]$表示对于前$i$个仓库轰炸$j$次的集合。②属性:最小 状态计算：$f[j][i]=f[j-1][k]+\\sum_{a=k+1}^i w[a]×(\\sum_{b=a+1}^i w[b])$ 我们用$s[i]=w[1]+w[2]+\\dots+w[i]$，$ms[i]=w[1]×s[1]+w[2]×s[2]+\\dots+w[i]×s[i]$ 于是上述式子可化简为$f[j][i]=f[j-1][k]+s[i]×(s[i]-s[k])+ms[k]-ms[i]$ 斜率表示：$f[j-1][k]+ms[k]=s[i]s[k]+f[j][i]-s^2[i]+ms[i]$ 于是若写成$Y=kX+b$，$Y=f[j-1][k]+ms[k]$，$X=s[k]$ 代码 #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; using namespace std; typedef long long ll; const int N=1010; int n,m,q[N]; ll w[N],s[N],ms[N]; ll f[N][N]; ll gety(int j,int a,int b) { return f[j][b]+ms[b]-f[j][a]-ms[a]; } ll getx(int a,int b) { return s[b]-s[a]; } int main() { while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n||m) { for(int i=1;i&lt;=n;++i) { scanf(&quot;%lld&quot;,&amp;w[i]); s[i]=s[i-1]+w[i];//前缀和 ms[i]=ms[i-1]+w[i]*s[i];//w[i]s[i]的前缀和 f[0][i]=s[i]*s[i]-ms[i];//初始化边界 } int tt,hh; for(int j=1;j&lt;=m;++j) { tt=1,hh=0; //f[j-1][j]这个更新过后要吧第j的点加入队列，j前面的点没有意义要删去 q[tt]=j; for(int i=j+1;i&lt;=n;++i)//仓库的个数是i之间的铁路个数是i-1,所以i-1&gt;=j { ll k=s[i]; while(tt&gt;hh&amp;&amp;gety(j-1,q[hh],q[hh+1])&lt;=getx(q[hh],q[hh+1])*k) hh++; f[j][i]=f[j-1][q[hh]]+s[i]*(s[i]-s[q[hh]])+ms[q[hh]]-ms[i]; while(tt&gt;hh&amp;&amp;gety(j-1,q[tt-1],q[tt])*getx(q[tt],i)&gt;=gety(j-1,q[tt],i)*getx(q[tt-1],q[tt])) tt--; q[++tt]=i; } } printf(&quot;%lld\\n&quot;,f[m][n]); } return 0; } 总结对于二维斜率优化，有一个关键的就是在第一层循环的时候初始化的tt=1,hh=0,q[tt]=j至于为什么需要q[tt]=j暂时还想的不是很明白:)，目前认为是上一层只有一个点有效的。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"/tags/动态规划/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"奇怪的建图方式","slug":"奇怪的建图方式","date":"2020-05-11T09:50:39.000Z","updated":"2020-05-12T12:37:32.280Z","comments":false,"path":"2020/05/11/奇怪的建图方式/","link":"","permalink":"/2020/05/11/奇怪的建图方式/","excerpt":"","text":"奇怪的建图方式一、2020.4.23学校测试题题目描述 蒟蒻回家种地后，突然听说武汉迫切需要医疗物资。他老家的田地在s点，可是武汉在e点，为了运输货物，中途需要经过很多城市，这导致快递费非常的贵，于是他准备自己开车，可是现在油价也不便宜，他尽量省一些油。 已知蒟蒻掌握着熟练的漂移技巧，当他在城市A时，他可以使用漂移到达城市B，这样耗费的油量为：$t×(A xor B)$，其中$t$为常数，$xor$为按位异或运算。此外他还可以不漂移，直接走公路，消耗的油量会给出。现在蒟蒻要从s到e点，请问他最少消耗多少升油? 输入格式 第一行三个数n($3≤n≤50000$)，m($0≤m≤100000$)，t($1≤t≤10^9$)代表有n个城市，共有m条连接城市的公路，和常数t。 第二行有两个数s，e，代表起点为s号城市，终点为e号城市。 第3到第m+2行，每行有三个数x，y，z，代表一条公路连接x号和y号城市，通过这条公路需要消耗z升 油，道路均为双向，两个城市间可能有多条道路连通。城市标号从1开始 输出格式 一行，一个数，为消耗的最少油量。 分析 很明显，题目是一个最短路问题，考虑对漂移方式的建图：如果将该点到其余所有点的漂移的边建出来发现最多可能需要建立$\\cfrac{n(n-1)}{2}$条边，所以总的边数为$m+\\cfrac{n(n-1)}{2}$，对于$dijkstra$算法复杂度是吃不消的。所以需要对漂移操作找一个更优的建边方式： 建异或的边考虑结合律(对于每一位的位运算是独立的考虑每一位的位运算然后相加)不需要把所有的边建出来 1101 -&gt; 1001 -&gt; 1011 -&gt; 10101101 -&gt; 1001 的代价是 1001001 -&gt; 1011 的代价是 101011 -&gt; 1010 的代价是 1 1101 -&gt; 10101101 -&gt; 1010 的代价是 111 所以发现上述是等价的，每次只考虑改变一个二进制位 总结一下：对于一个点到另一个点是对改变k次二进制位，每次对当前的点改变一个二进制位，能够达到漂移到任意点的效果。（但是要借助0这个点以达到枚举所有漂移情况） 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; typedef long long ll; typedef pair&lt;ll,int&gt;PLI; const int N=50010,M=1000020; int h[N],e[M],ne[M],idx; ll w[M]; ll dist[N]; bool st[N]; int n,m,t,start,ed; void add(int a,int b,ll c) { e[idx]=b; w[idx]=c; ne[idx]=h[a]; h[a]=idx++; } ll dijkstra() { memset(dist,0x3f,sizeof dist); priority_queue&lt;PLI,vector&lt;PLI&gt;,greater&lt;PLI&gt; &gt;heap; heap.push({0,start}); dist[start]=0; while(heap.size()) { int t=heap.top().second; heap.pop(); if(st[t]) continue; st[t]=1; for(int i=h[t];i!=-1;i=ne[i]) { int j=e[i]; if(dist[j]&gt;dist[t]+w[i]) { dist[j]=dist[t]+w[i]; heap.push({dist[j],j}); } } } return dist[ed]; } int main() { memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;start&gt;&gt;ed; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c),add(b,a,c); } for(int i=0;i&lt;=n;i++)//借助0这个点 for(int j=0;j&lt;17;j++) if((i^(1&lt;&lt;j))&lt;=n) add(i,i^(1&lt;&lt;j),1ll*t*(1&lt;&lt;j)); cout&lt;&lt;dijkstra()&lt;&lt;endl; return 0; } //由于现在没有测试平台，此代码不一定正确但是思想没问题 二、算法进阶指南——装满的油箱题目描述 有N个城市（编号0、1…N-1）和M条道路，构成一张无向图。 在每个城市里边都有一个加油站，不同的加油站的单位油价不一样。 现在你需要回答不超过100个问题，在每个问题中，请计算出一架油箱容量为C的车子，从起点城市S开到终点城市E至少要花多少油钱？ 注意： 假定车子初始时油箱是空的。 输入格式 第一行包含两个整数N和M。 第二行包含N个整数，代表N个城市的单位油价，第i个数即为第i个城市的油价pipi。 接下来M行，每行包括三个整数u,v,d，表示城市u与城市v之间存在道路，且车子从u到v需要消耗的油量为d。 接下来一行包含一个整数q，代表问题数量。 接下来q行，每行包含三个整数C、S、E，分别表示车子油箱容量、起点城市S、终点城市E。 输出格式 对于每个问题，输出一个整数，表示所需的最少油钱。 如果无法从起点城市开到终点城市，则输出”impossible”。 每个结果占一行。 数据范围 1≤N≤1000,1≤M≤10000,1≤p_i≤1001≤d≤100,1≤C≤100分析 如何表示状态？ 对于每个状态有两点决定：①现在在什么地方②现在油箱有多少油。因此考虑分层图即拆点建图dist[k][c]：表示目前在k这个位置邮箱剩余油量为c这个状态。 如何转移状态？①对于k来说遍历该点的临边②对于c来说可以在该点加油（加油可以加任意升但是只需要考虑每次加一升油就可以实现加任意升油情况） 代码 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; using namespace std; const int N=1010,M=20010,C=110; int h[N],e[M],ne[M],w[M],idx; int price[N]; int dist[N][C]; bool st[N][C]; int n,m; struct ver { int d,u,c; bool operator&lt; (const ver &amp;w) const { return d&gt;w.d; } }; void add(int a,int b,int c) { e[idx]=b; ne[idx]=h[a]; w[idx]=c; h[a]=idx++; } int dijkstra(int start,int ed,int cap) { memset(dist,0x3f,sizeof dist); memset(st,0,sizeof st); priority_queue&lt;ver&gt; heap; heap.push({0,start,0}); dist[start][0]=0; while(heap.size()) { auto t=heap.top(); heap.pop(); if(t.u==ed&amp;&amp;t.c==0) return t.d; if(st[t.u][t.c]) continue; st[t.u][t.c]=1; if(t.c&lt;cap) { if(dist[t.u][t.c+1]&gt;t.d+price[t.u]) { dist[t.u][t.c+1]=t.d+price[t.u]; heap.push({dist[t.u][t.c+1],t.u,t.c+1}); } } for(int i=h[t.u];i!=-1;i=ne[i]) { int j=e[i]; if(t.c&gt;=w[i]) { if(dist[j][t.c-w[i]]&gt;t.d) { dist[j][t.c-w[i]]=t.d; heap.push({dist[j][t.c-w[i]],j,t.c-w[i]}); } } } } return -1; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); for(int i=0;i&lt;n;i++) cin&gt;&gt;price[i]; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c),add(b,a,c); } int query; cin&gt;&gt;query; while(query--) { int a,b,c; cin&gt;&gt;c&gt;&gt;a&gt;&gt;b; int t=dijkstra(a,b,c); if(t==-1) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; else cout&lt;&lt;t&lt;&lt;endl; } return 0; } 总结发现上述两题有一个共同特点：每次进行1次操作来实现k次操作都用。第一题：改变k次二进制位每次考虑改变一位。第二题：每次可以加k升油考虑每次只加一升油。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"图论","slug":"图论","permalink":"/tags/图论/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"树状数组","slug":"树状数组","date":"2020-05-06T07:00:26.000Z","updated":"2020-05-11T09:49:12.260Z","comments":false,"path":"2020/05/06/树状数组/","link":"","permalink":"/2020/05/06/树状数组/","excerpt":"","text":"树状数组聊聊前缀和比如数组 int a[7]={1,2,3,4,5,6,7} 如果需询问数组从第l个数到第r个数的和暴力做法时间复杂度为$O(n)$ 不过我们可以预处理一个前缀和数组 int b[7]={1,3,6,10,15,21,28} 比如要询问[l,r]区间的和我们可以这样做b[r]-b[l-1]这也时间复杂度为$O(1)$ 但是问题来了，如果我们要既要修改数组中元素的值，有要进行上述区间查询操作呢？ 我们发现每次我们修改原数组中元素的值时间复杂度为$O(1)$但是如果修改前缀和数组中元素的值时间复杂度将会退化到$O(n)$ 总结一下： 数组 修改元素的值时间复杂度 区间求和时间复杂度 原数组 O(1) O(n) 前缀和数组 O(n) O(1) 我们可以发现如果需要单点更新和区间查询两种操作时间复杂度都是$O(n)$ 什么是树状数组?树状数组是一种便于进行单点更新和区间查询的数据结构 树状数组相关操作 二进制中最后一个1——$lowbit$ int lowbit(int x) { return x&amp;-x; } 单点更新 我们对数组位置为x的元素加上c //树状数组为tree，数组元素个数为n，数组下标从0开始 void add(int x,int c) { for(;x&lt;=n;x+=lowbit(x)) tree[x]+=c; } 区间求和 //求出[1,x]数组中的总和即前缀和 int sum(int x) { int res=0; for(;x;x-=lowbit(x)) res+=tree[x]; return res; } 局限性我们很容易发现上述树状数组只适用于单点更新和区间查询，但是如果是区间修改和单点查询好像力不从心 差分在树状数组中的应用告诉你个好消息如果有差分的介入，那么树状数组可以进行区间更新和单点查询当然也可以进行更厉害的区间更新和区间查询。 区间更新、单点查询我们把$tree[]$数组构造成一个差分数组还是看题吧 题目 给定长度为N的数列A，然后输入M行操作指令。 第一类指令形如“C l r d”，表示把数列中第l~r个数都加d。 第二类指令形如“Q X”，表示询问数列中第x个数的值。 对于每个询问，输出一个整数表示答案。 输入格式 第一行包含两个整数N和M。 第二行包含N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式 对于每个询问，输出一个整数表示答案。 每个答案占一行。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N=100010; ll tree[N]; int n,m; int lowbit(int x) { return x&amp;-x; } void add(int x,int c) { for(;x&lt;=n;x+=lowbit(x)) tree[x]+=c; } ll sum(int x) { int res=0; for(;x;x-=lowbit(x)) res+=tree[x]; return res; } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { int a; cin&gt;&gt;a; add(i,a); add(i+1,-a); } while(m--) { char t; cin&gt;&gt;t; if(t==&#39;Q&#39;) { int x; cin&gt;&gt;x; cout&lt;&lt;sum(x)&lt;&lt;endl; } else { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,c); add(b+1,-c); } } return 0; } 我们可以发现对于上述代码即在建树的过程中建成差分树的形式即可 区间更新、区间查询原数组a[]，对于区间更新我们可以维护一个差分数组b[] 如果我们维护数组a的前缀和我们可以发现有下面等式： \\sum_{i=1}^x a_i=\\sum_{i=1}^x\\sum_{j=1}^i b_i=\\sum_{i=1}^x(x-i+1)b_i变换一下： \\sum_{i=1}^x a_i=(x+1)\\sum_{i=1}^x b_i-\\sum_{i=1}^x b_i×i 于是我们可以维护两个差分树状数组$tree1[]$维护$ bi $、$tree2[]$维护$i*bi$ 给定一个长度为N的数列A，以及M条指令，每条指令可能是以下两种之一： 1、“C l r d”，表示把 A[l],A[l+1],…,A[r] 都加上 d。 2、“Q l r”，表示询问 数列中第 l~r 个数的和。 对于每个询问，输出一个整数表示答案。 输入格式 第一行两个整数N,M。 第二行N个整数A[i]。 接下来M行表示M条指令，每条指令的格式如题目描述所示。 输出格式 对于每个询问，输出一个整数表示答案。 每个答案占一行。 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; const int N=100010; int n,m; ll tree1[N],tree2[N]; //维护b[i] 维护i*b[i] int lowbit(int x) { return x&amp;-x; } void add(ll tree[],int x,ll c) { for(;x&lt;=n;x+=lowbit(x)) tree[x]+=c; } ll sum(ll tree[],int x) { ll res=0; for(;x;x-=lowbit(x)) res+=tree[x]; return res; } ll prefix_sum(int x) { return (x+1)*sum(tree1,x)-sum(tree2,x); } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { int a; scanf(&quot;%d&quot;,&amp;a); add(tree1,i,a); add(tree1,i+1,-a); add(tree2,i,1ll*i*a); add(tree2,i+1,-1ll*(i+1)*a); } while(m--) { char t; int l,r; cin&gt;&gt;t&gt;&gt;l&gt;&gt;r; if(t==&#39;Q&#39;) { scanf(&quot;%d%d&quot;,&amp;l,&amp;r); cout&lt;&lt;prefix_sum(r)-prefix_sum(l-1)&lt;&lt;endl; } else { int d; scanf(&quot;%d&quot;,&amp;d); add(tree1,l,d),add(tree1,r+1,-d); add(tree2,l,l*d),add(tree2, r+1,-1ll*(r+1)*d); } } return 0; } 总结 2020/5/6学习树状数组，树状数组可以优化很多问题未来等遇到了在加进去 以上题目来自于$lyd$老师的《算法进阶指南》参考$lcf$大佬博客","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"/tags/数据结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}